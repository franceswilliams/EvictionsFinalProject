---
title: "Model Building: Predictors of Eviction in Brooklyn, 2010-2016"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
options(scipen = 999)
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(readxl)
library(plotly)
library(geepack)
library(pstools)

joined_data_bklyn_nomissing = 
  readRDS('./data/joined_data_bklyn_nomissing')
```

### Count-based outcome (Poisson)

Since our outcome, eviction rate, is calculated using a **count** variable (number of evictions) repeated over time within areas, we'll model it using GEE with a Poisson link function.

```{r, echo = FALSE, message = FALSE}
## poisson distribution of counts (and rates)
joined_data_bklyn_nomissing %>% 
  ggplot(aes(x = eviction_rate)) + 
  geom_histogram(binwidth = 0.1) +
  theme_light() +
  labs(x = "Eviction count per 100 renter-occupied households",
       y = "Count",
       title = "Distribution of eviction counts, standardized by area") +
  theme(plot.title = element_text(hjust = 0.5))
```

&nbsp;
&nbsp;

**Model:**

<!-- LaTeX code - edit on https://www.codecogs.com/latex/eqneditor.php, then download gif -->

<!-- $$ -->
<!-- (1) \hspace{20mm} log\{E({Y_{ij})}\} = log(n_{ij}) + \beta_0 + \beta_1*X_{ij} + \beta_2*year_{ij} \\ -->
<!-- \hspace{20mm}\\ -->
<!-- \hspace{20mm} \text{Where: }\\ -->
<!-- \hspace{20mm} _{ij}\hspace{2mm} \text{denotes Census Tract \textit{i} and year \textit{j}} \\ -->
<!-- \vspace{.01mm} \\ -->
<!-- \hspace{20mm}E({Y_{ij})} = \text{expected count of evictions} \\ -->
<!-- \hspace{20mm} n_{ij} = \text{offset term (number of renter-occupied housing units)} \\ -->
<!-- \hspace{20mm}X_{ij} = \begin{cases}\text{Area percent of population that speaks English less than "Very Well"} -->
<!-- \\ \text{Mean area rent burden (percentage of household income spent on rent)} -->
<!-- \\ \text{Area percent of population that is nonwhite} -->
<!-- \\ \text{Crude area population density (total population divided by area (mi} ^2) -->
<!-- \end{cases}\\ -->
<!-- $$ -->

&nbsp; 
&nbsp;

![](./images/eq1.gif)

&nbsp;
&nbsp;


#### Univariable Poisson GEE models

```{r, message = FALSE}
## trying glm with Poisson
univariate_poi = function(x){
  
  gee_poi = geeglm(evictions ~ 
                   #(eviction_filings - evictions) ~ ## testing discrepancy in rate as outcome - subtracted counts, kept offset
                   offset(log(renter_occupied_households)) + x + years_since_2010, ## here i removed the int term
                   data = joined_data_bklyn_nomissing, 
                   id = geoid, 
                   family = poisson, 
                   corstr = "ar1") %>% ## ar(1) corstr due to autocorrelation in data across time
  broom::tidy(conf.int = FALSE,
              conf.level = 0.95,
              exponentiate = FALSE,
              quick = FALSE)
  tibble(
    b0_est = gee_poi[[1,2]],
    b0_p = gee_poi[[1,5]],
    b1_est = gee_poi[[2,2]],
    RR = exp(gee_poi[[2,2]]),
    RR_10 = exp(gee_poi[[2,2]]*10),
    b1_p = gee_poi[[2,5]],
    year_b2_est = gee_poi[[3,2]],
    year_RR = exp(gee_poi[[3,2]]),
    year_p = gee_poi[[3,5]],
    # interaction_est = gee_poi[[4,2]], ## removed the int term
    # interaction_p = gee_poi[[4,5]]
  )
  
}

pred_poi_list = list("pct_eng" = pull(joined_data_bklyn_nomissing, pct_eng), 
                     "rent_burden" = pull(joined_data_bklyn_nomissing, rent_burden), 
                     "pct_nonwhite" = pull(joined_data_bklyn_nomissing, pct_nonwhite_racedata), 
                     "pop_density" = pull(joined_data_bklyn_nomissing, total_pop_densitydata)
                     )

gee_poi_output = map(pred_poi_list, univariate_poi) %>%
  do.call(rbind, .) %>%
  knitr::kable(digits = 2,
               caption = "Univarable GEE parameter estimates: predicted change in rate of evictions (standardized by area-specific number of renter-occupied households)")

gee_poi_output
```

However, we see that when controlling for percent African Americans comprising a community, the association between `pct_eng` and `evictions` flips. Above, we see that as `pct_eng` - the percentage of individuals who speak English less than 'Very Well'- goes up, eviction rates decrease, on average.

African Americans are a predominantly English-speaking community in the US but are nonetheless more vulnerable to evictions than White individuals. In this way, the relationship between `pct_eng` and `evictions` was actually being confounded by the percentage of African Americans in a community: a group with high rates of English fluency, and a predominant population in many areas of Brooklyn, was still experiencing higher rates of eviction.

Thus, after controlling for `pct_af_am`, we see the following estimates for `pct_eng` predicting `evictions`:

```{r, echo = FALSE}
## side note - controlling for pct_af_am in pct_eng analyses
gee_poi_pct_eng = 
  geeglm(evictions ~ 
                   offset(log(renter_occupied_households)) + pct_eng + pct_af_am + years_since_2010, ## here i removed the int term
                   data = joined_data_bklyn_nomissing, 
                   id = geoid, 
                   family = poisson, 
                   corstr = "ar1") %>% ## ar(1) corstr due to autocorrelation in data across time
  broom::tidy(conf.int = FALSE,
              conf.level = 0.95,
              exponentiate = FALSE,
              quick = FALSE)

pct_eng_output =   
tibble(
    b0_est = gee_poi_pct_eng[[1,2]],
    b0_p = gee_poi_pct_eng[[1,5]],
    b1_est = gee_poi_pct_eng[[2,2]],
    RR = exp(gee_poi_pct_eng[[2,2]]),
    RR_10 = exp(gee_poi_pct_eng[[2,2]]*10),
    b1_p = gee_poi_pct_eng[[2,5]],
    year_b2_est = gee_poi_pct_eng[[3,2]],
    year_RR = exp(gee_poi_pct_eng[[3,2]]),
    year_p = gee_poi_pct_eng[[3,5]],
    # interaction_est = gee_poi_pct_eng[[4,2]], ## removed the int term
    # interaction_p = gee_poi_pct_eng[[4,5]]
  )

pct_eng_output %>% 
  knitr::kable(digits = 2)
```

As we can see, the association has been flipped, and the relationship between English non-fluency and eviction is positive, controlling for percentage of African Americans.

__Example Interpretations of Parameter Estimate__

  * For the exponentiated beta estimate (`b1_est`) for `pct_nonwhite`: For every 1 percent increase in nonwhite residents, the population-average eviction rate is expected to increase by 2.2 percent, on average, controlling for year (RR = 1.022, 95% CI [to be calculated by modifying code]). Given a 10 percent increase in nonwhite residents, we would expect the population-average eviction rate to increase by 22 percent, on average, controlling for year (represented by `RR_10`).

#### Multivariable Poisson GEE model

Since the effect of population density on eviction count wasn't statistically significant, controlling for year, we won't include it in our multivariable model. Thus, our multivariable model will take the form:

&nbsp;
&nbsp;

<!-- $$ -->
<!-- (2) \hspace{1mm} log\{E({Y_{ij})}\} = log(n_{ij}) + \beta_0 + \beta_1*X_{1ij} + \beta_2*X_{2ij} + \beta_3*X_{3ij} + \beta_4*year_{ij} \\ -->
<!-- \hspace{20mm}\\ -->
<!-- \hspace{20mm} \text{Where: }\\ -->
<!-- \hspace{20mm}X_{(k)ij}, \text{where \textit{k} = \begin{cases}\text{1: Area percent of population that speaks English less than "Very Well"} -->
<!-- \\ \text{2: Mean area rent burden (percentage of household income spent on rent)} -->
<!-- \\ \text{3: Area percent of population that is nonwhite} -->
<!-- \end{cases}\\ -->
<!-- $$ -->

![](./images/eq2.gif)

__Next Steps__

  * Correlation analysis of predictors (prevent multicollinearity)
  * Raw plots of predictor vs. outcome? Log outcome? How to visualize?
  * Model building process ideas:
    + Fit vs. Residual plots, with investigation of outliers
    + Compare models to saturated models (i.e. all main effects and interaction terms)
    + Cross-validation of models
  * Shiny app that builds model based on any variable we have (output = # evictions per 100 renter households per year)

***

## Correlation Plot

```{r}
joined_data_bklyn_nomissing %>% 
  select(-pct_nonwhite_racedata, -pct_af_am, am_ind_ak_native = aian) %>% 
  select_if(is.numeric) %>% 
  cor() %>% 
  corrplot::corrplot(type = "lower",
                     method = "square", 
                     addCoef.col = "black", 
                     diag = FALSE, 
                     number.cex = .7,
                     tl.col = "black",
                     tl.cex = .9)
```


## Hypothesized Model

```{r}
hyp_fit = 
  geeglm(evictions ~
           )

## need to include `black` since confounds pct_eng -> evictions relationship
  ## but `black` also collinear with `pct_nonwhite`, which we want as a predictor
  ## solution: include all races?
```

## Model Fitting using `gee_stepper`

```{r}
## use full dataset
full_fit =
  geeglm(evictions ~ 
           offset(log(renter_occupied_households)) + years_since_2010 +
           pct_eng + rent_burden + pct_nonwhite_racedata + density + ## hypothesized
           black + aian + asian + nhpi + other + ## race
           poverty_rate + pct_renter_occupied + median_gross_rent + median_household_income + median_property_value,
         data = joined_data_bklyn_nomissing,
         id = geoid,
         family = poisson,
         corstr = "ar1")

gee_stepper_o(full_fit, formula(full_fit)) ## customized function to automatically include offset and time covariate

```

Covariates selected by stepwise selection (using QIC):  
  * [`offset`] - held constant
  * [`years_since_2010`] - held constant
  * `rent_burden`
  * `density`
  * `nhpi`
  * `black`
  * `other`
  * `poverty_rate`
  * `median_household_income`
  * `median_gross_rent`
  * `median_property_value`
  * `pct_renter_occupied`

Final formula:
```{r}
step_model = 
  geeglm(formula = evictions ~ years_since_2010 + black + median_property_value + 
    other + median_household_income + density + rent_burden + 
    poverty_rate + nhpi + median_gross_rent + pct_renter_occupied + 
    offset(log(renter_occupied_households)), family = poisson, 
    data = joined_data_bklyn_nomissing, id = geoid, corstr = "ar1")
```

